## The first (and most interesting part) of the internal MMC
- The first 34 sectors are just the GPT ofcourse
- After this the Samsung PIT is stored, which is 4KiB, and thus 8 sectors long
- After this some MD5 sums in ASCII text and repetitive data is stored (could be Thumb code, but not very likely) until sector 256, so this is 214 sectors long. Everything after the first 48 sectors is only zeroes though. It might be called GANG, because it starts right after the PIT, and according to the PIT a partition called GANG is located there.
- After this the first MLO (MLO1) is stored. Directly after this the second MLO (MLO2) follows. They are both exaclty 128KiB long, so combined this takes 512 sectors of space. These are both the Texas Instruments X-Loader, which is an open source primary bootloader. They are almost the same, and the only difference is that the keys (they are signed) are different. This signing is enforced because the Samsung Galaxy Tab 2 is a HS device, so if you change the primary bootloader, the tablet will refuse to boot past the ROM code (stored on the SoC itself).
- The last hidden "partition" that is at the beginning of the MMC is only 1 sector long, and in fact only the first 128 bytes are used, and the remaining bytes are all zeroes. It contains some properties of the device, such as the model number, but also some variables, such as the flash counter. which should not be changed even if new firmware is flashed, or at least according to Samsung >:(
## Real partitions on the internal MMC
- EFS
	+ This is an ext4 partition that contains some small text files that specify the WiFi and bluetooth MAC address, certificates and other things.
- SBL1
	+ The second stage bootloader, see the ``Sbl.bin`` heading.
- SBL2
	+ The backup of the second stage bootloader, this is byte by byte the same as SBL1
- PARAM
	+ This is a j4fs partition that contains files used by the second stage bootloader, such as splash JPEG images and text files that specify if an update is is in progress for example, or the debug level. It also contains a file called ``param.blk`` which is a binary representation of the environment in the Sbl. This also contains the command line parameters for the kernel for example.
- RECOVERY
	+ The recovery android kernel image, speaks for itself.
- CACHE
	+ Speaks for itself.
- MODEM
	+ Modem firmware.
- FACTORYFS
	+ This is the android sparse system image.
- DATAFS
	+ ext4 user data.
- HIDDEN
	+ Android sparse image of data that gets copied to userdata after factory reset. It contains some video's, images and default installed apps.
- Furthermore there is (apart from the GPT backup ofcourse no other data at the end of the disk).
### `MLO`
- The X-Loader is the first stage bootloader for the OMAP platform, it gets loaded by the boot ROM at `0x40300800`, which is in SRAM. It can be loaded either from the SD card or from internal MMC. The only things it does are initialize the DRAM, UART and different storage devices. The X-Loader loads the second stage bootloader from the same device as it was loaded itself, which will come in handy later. The X-Loader for the Samsung Galaxy Tab 2 is pretty much an unmodified version of the generic X-Loader for the omap44XXtablet from Texas Instruments. The only difference is the position and size the X-Loader looks for the second stage bootloader on the storage device. These are hardcoded to be sector `0xc000` and `0xd000` for SBL1 and SBL2 respectively, the size is `0x140000` bytes for both, so changing the GPT or PIT has no effect on where it looks.
### `Sbl.bin`
-  This is the second stage bootloader for the Samsung Galaxy Tab 2, it gets loaded by the X-Loader at address `0x80008000`. This is a proprietary bootloader, and sadly the Samsung Electronics leak of March 2022 doesn't contain the bootloader source for such old devices (No OMAP device source to be found). And the second stage bootloader also doesn't do anything different if it is loaded from an external SD card instead of internal storage, but to make things even worse: It also doesn't log much via UART, and by default also doesn't respond to any input from UART.
#### Reverse engineering with Ghidra
- The first step in reverse engineering ``Sbl.bin`` was to get some UART output and input, this was achieved quite quickly because all UART functions ofcourse use strings or characters which are easy to recognize. I discovered that more logging was simply disabled by Samsung by setting the pointer to the UART functions equal to some empty stub functions before and after a certain point, so by setting this pointer equal to the real UART functions in both cases a lot more was logged, and by pressing any key during boot Autoboot could be aborted, so that you are dropped into a prompt where commands can be entered. The set of commands sadly didn't contain anything for booting to a different device (only changing the kernel load address, not the load device).
- After this I quickly found out that the MMC device memory base was `0x480b4000` for internal storage and `0x4809c000` for the SD card. This `0x480b4000` was hardcoded in a function which registers the MMC device, so I decided to see if it was simply a case of changing this to `0x4809c000`, but this resulted in all functions which read from storage to fail. I also saw that this address was used in some other places in this function (to only execute code in case of the base being `0x480b4000` for example), but changing all (or some) occurrences also didn't work.
- After this I decided to see if the memory that the first function to get something from storage (the PIT printing function) populated, containted some recognizable stuff (such as strings), so that I could maybe find out why this wasn't working. I did this by placing a modified version of the UART print string function (modified by always printing a fixed amount of bytes, and not null terminated) at an unused part of the `Sbl.bin` file (I ended up placing it at `0x6a000`). I then called this function from the PIT printing function, and indeed if I used the internal storage memory base, I could see that the PIT binary was dumped via UART, but when I changed the storage device to be used to the SD card, I only saw mostly random garbage, which was also different each time I rebooted the tablet, so I suspected that maybe this driver was anticipating all 8 data lines to be connected to the SD card, while in reality only 4 are connected, but since this is something I can't really change and would be way to difficult to change in the disassembled `Sbl.bin` I went for another approach.
- I thought that maybe it could be a good idea to copy a build of X-loader from source to the SBL1 partition, so that effectively the first stage bootloader is loaded a second time, and this could then load both the kernel and the second stage bootloader to memory, so that the second stage only has to execute instead of load and execute. But this would never really work because the second stage bootloader is position dependent, and it would be too much work to change the whole binary file (of about 1.3MB!) to take into account that it will be loaded at a different address (since it cannot be loaded at the same address the second X-Loader is loaded (`0x80008000`). I did get the second X-Loader to boot and successfully load the second stage from the SD card to memory, but when it started executing the second stage bootloader (at `0x80e80000`) it hangs. And it would not really be feasable to let X-Loader load the linux kernel directly, since it doesn't support android boot images and also doesn't initialize the screen and framebuffer.
- The last thing I tried was to let `Sbl.bin` execute the MMC functions from the X-Loader (which is still in memory at the same address at that point!). Amazingly this worked for the internal storage, and the PIT was once again dumped to UART, although it did require some absolute branches instead of relative, because the SRAM addresses are quite far away from our `0x80008000`. But to my surprise changing the MMC device from 1 (internal) to 0 (SD) (the X-Loader uses indices instead of memory bases for configuring the MMC device), it didn't work, even though these exact same functions did work in the X-Loader itself evident by the fact that `Sbl.bin` was successfully executed. This lead me to my final conculsion that something must be wrong with the pin muxing, so I started looking at the different ways pins were set between the X-Loader and second stage bootloader, and I found out that the GPIO pin that enabled power for the MMC (GPMC_AD10 (0x4a100054)) was set as an input and pulled down in the second stage bootloader, turning off the SD card, which explains why random data was read from it. Changing this to be an output and high, and only changing the `0x480b4000` to `0x4809c000` in the one place I discussed before worked!! It made the second stage bootloader load everything from the SD card, even the PIT and the PARAM partition.

## Kernel
